## android内存泄漏
##### 首先我们要先认识java的内存分配策略

1.静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。

2.栈：方法体内定义的局部变量，一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的

3.堆：又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。
成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。

java内存是由程序员分配的，但是回收是由GC来回收的，，虽然这样简化了程序员的工作，但是加重了JVM的工作，因为GC要一直监测内存的变化，所以这也是java程序运行较慢的原因之一

内存泄漏的最主要的原因就是程序中存在无用的对象，但是这些对象仍然再引用着，没有被释放

##### 内存泄漏原因：
1.忘记释放分配的内存导致  比如cursor，监听器，eventbus的注册，这些都可以再activity中的ondestroy的生命周期方法中释放掉内存

2.static导致的内存泄漏   像static activity，static view，因为static变量是贯穿这个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被垃圾回收器回收。

3.内部类：内部类的优势之一就是可以访问外部类，但是导致内存泄漏的原因，就是内部类持有外部类实例的强引用。

4.匿名类：比如AsyncTask，当异步任务在后台执行耗时任务期间引入了一个activity，但是中途Activity不幸被销毁了这个被AsyncTask持有的Activity实例就不会被垃圾回收器回收，直到异步任务结束。

5.Handler：同样道理，[定义匿名的Runnable，用匿名类Handler执行，Runnable内部类会持有外部类的隐式引用，被传递到Handler的消息队列MessageQueue中，在Message消息没有被处理之前，Activity实例不会被销毁了，于是导致内存泄漏。